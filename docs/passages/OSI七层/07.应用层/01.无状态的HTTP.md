---
title: "无状态的HTTP"
date: '2019-7-1'
permlink: "2019-7-1-http-stateless"
---

**什么是无状态性？**    
无状态是指，当浏览器发送请求给服务器的时候，服务器响应客户端请求,但是当同一个浏览器再次给你服务器发送请求的时候，服务器并不知道它就是刚才那个浏览器。

简单的说，服务器不会记得你，所以就是无状态协议,所以每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。

| OSI  |  协议 |   状态性
|-------|------|----------
|应用层 | HTTP  |   无
|传输层 | TCP   |   有
|传输层 | UDP   |   无
|网络层 | IP    |   有
|链路层 | ARP   |   无


### Web应用
www应用也称web应用，很多时候，www应用是需要每个HTTP请求或应答动作之间是有关联的，那就是使应用有状态。这样才能提供给用户最好的用户体验。


**web应用都有哪些方法来让应用有状态？**     
之所以说web应用是有状态的。是因为我们加入了`cookies、session、application`等机制去实现有状态的web应用。所以我们可以这么理解：`Web应用=http协议+session、cookies`等状态机制+其他辅助的机制。

**FAQ:** 于是，问题就来了，为什么当初HTTP会设计成无状态的，既然现在我们所需要的www应用是有状态的，为什么给他提供的这样的底层协议是无状态的。从历史的角度去思考。早期的www应用只是浏览内容的，无状态的协议已经够了，这样实现可以减轻实现的负担，因为有状态的协议实现起来代价相对来说是很高的（要维护状态，根据状态来处理情况，这就是为什么建议你可以不用session的时候就不用，因为服务器要给你负担起很多的东西，例如内存空间啊）。好，现在看来，似乎www 应用是大部分需要状态了，那么是否我们就应该改变这个协议来让他变成一个有状态的协议呢？从这个角度上讲，我认为是不应该的。因为想要基于http协议的web应用变得有状态，实现起来并不麻烦。


我们做一个网络应用，需要使用网络协议。其实按照原理上讲，标准的TCP/IP协议族提供给我们的应用层协议(FTP,　HTTP)不能直接的被称为应用，因为在实现某种可用的、直接面向用户的应用的时候（如web应用，人们可以上网），只有http协议还是不够的。所以我们可以这么理解。网络标准协议分层中提供给我们的应用层协议，它更像是一种分类。自然界的应用可能是无穷尽的种类，但是根据他们的特点、传输的特色，标准的网络协议在传输层（通用网络协议）的基础上封装出若干种面向不同种类网络应用的协议。


### HTTP协议
HTTP是无状态的，它的底层协议是由状态的TCP，但是HTTP的一次完整协议动作，里面是使用有状态的TCP协议来完成的。而每次协议动作之间没有任何关系。例如：第7次请求HTTP协议包，并不知道，这个包是为了什么？它或许是因为上次没有请求成功而重传，或许是上次的后续请求，或许是其他的，这些HTTP自身都不知道。

### TCP协议
TCP是有状态的，它通过包头中的一些控制字段（序列编码等）来表明各个包之间的关系（前后关系，重包与否等等）。所以，通过这个协议你可以做到一个可靠的传输。那么TCP是面向连接的协议是什么意思呢？其实这里的面向连接其实就是“三次握手”。三次握手，首先可以保证对方的存在，其次握手的所交换的内容是为将来进行有状态的传输做准备。

### UDP协议
UDP是无状态的，它仅仅是在IP上加了Port，其他的事情什么也不干。这样它不可能做到可靠的传输，同样也不需要连接。

### IP协议
IP是无状态的，它只负责将一个IP包发送到指定的IP地址上去。它不会考虑这个包与前面已经发送的包和后面的包的联系。（可能是重发包、可能是不连续包，它不管）

### ARP协议
**ARP协议的缺陷** ARP协议是建立在信任局域网内所有结点的基础上的，它很高效，但却不安全。它是无状态的协议，不会检查自己是否发过请求包，也不管（其实也不知道）是否是合法的应答，只要收到目标MAC是自己的ARP reply包或arp广播包（包括ARP request和ARP reply），都会接受并缓存。这就为ARP欺骗提供了可能，恶意节点可以发布虚假的ARP报文从而影响网内结点的通信，甚至可以做`“中间人”`。

