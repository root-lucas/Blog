(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{177:function(t,v,_){"use strict";_.r(v);var r=_(2),s=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[_("strong",[t._v("什么是无状态性？")]),_("br"),t._v("\n无状态是指，当浏览器发送请求给服务器的时候，服务器响应客户端请求,但是当同一个浏览器再次给你服务器发送请求的时候，服务器并不知道它就是刚才那个浏览器。")]),t._v(" "),_("p",[t._v("简单的说，服务器不会记得你，所以就是无状态协议,所以每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("OSI")]),t._v(" "),_("th",[t._v("协议")]),t._v(" "),_("th",[t._v("状态性")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("应用层")]),t._v(" "),_("td",[t._v("HTTP")]),t._v(" "),_("td",[t._v("无")])]),t._v(" "),_("tr",[_("td",[t._v("传输层")]),t._v(" "),_("td",[t._v("TCP")]),t._v(" "),_("td",[t._v("有")])]),t._v(" "),_("tr",[_("td",[t._v("传输层")]),t._v(" "),_("td",[t._v("UDP")]),t._v(" "),_("td",[t._v("无")])]),t._v(" "),_("tr",[_("td",[t._v("网络层")]),t._v(" "),_("td",[t._v("IP")]),t._v(" "),_("td",[t._v("有")])]),t._v(" "),_("tr",[_("td",[t._v("链路层")]),t._v(" "),_("td",[t._v("ARP")]),t._v(" "),_("td",[t._v("无")])])])]),t._v(" "),_("h3",{attrs:{id:"web应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web应用"}},[t._v("#")]),t._v(" Web应用")]),t._v(" "),_("p",[t._v("www应用也称web应用，很多时候，www应用是需要每个HTTP请求或应答动作之间是有关联的，那就是使应用有状态。这样才能提供给用户最好的用户体验。")]),t._v(" "),_("p",[_("strong",[t._v("web应用都有哪些方法来让应用有状态？")]),_("br"),t._v("\n之所以说web应用是有状态的。是因为我们加入了"),_("code",[t._v("cookies、session、application")]),t._v("等机制去实现有状态的web应用。所以我们可以这么理解："),_("code",[t._v("Web应用=http协议+session、cookies")]),t._v("等状态机制+其他辅助的机制。")]),t._v(" "),_("p",[_("strong",[t._v("FAQ:")]),t._v(" 于是，问题就来了，为什么当初HTTP会设计成无状态的，既然现在我们所需要的www应用是有状态的，为什么给他提供的这样的底层协议是无状态的。从历史的角度去思考。早期的www应用只是浏览内容的，无状态的协议已经够了，这样实现可以减轻实现的负担，因为有状态的协议实现起来代价相对来说是很高的（要维护状态，根据状态来处理情况，这就是为什么建议你可以不用session的时候就不用，因为服务器要给你负担起很多的东西，例如内存空间啊）。好，现在看来，似乎www 应用是大部分需要状态了，那么是否我们就应该改变这个协议来让他变成一个有状态的协议呢？从这个角度上讲，我认为是不应该的。因为想要基于http协议的web应用变得有状态，实现起来并不麻烦。")]),t._v(" "),_("p",[t._v("我们做一个网络应用，需要使用网络协议。其实按照原理上讲，标准的TCP/IP协议族提供给我们的应用层协议(FTP,　HTTP)不能直接的被称为应用，因为在实现某种可用的、直接面向用户的应用的时候（如web应用，人们可以上网），只有http协议还是不够的。所以我们可以这么理解。网络标准协议分层中提供给我们的应用层协议，它更像是一种分类。自然界的应用可能是无穷尽的种类，但是根据他们的特点、传输的特色，标准的网络协议在传输层（通用网络协议）的基础上封装出若干种面向不同种类网络应用的协议。")]),t._v(" "),_("h3",{attrs:{id:"http协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http协议"}},[t._v("#")]),t._v(" HTTP协议")]),t._v(" "),_("p",[t._v("HTTP是无状态的，它的底层协议是由状态的TCP，但是HTTP的一次完整协议动作，里面是使用有状态的TCP协议来完成的。而每次协议动作之间没有任何关系。例如：第7次请求HTTP协议包，并不知道，这个包是为了什么？它或许是因为上次没有请求成功而重传，或许是上次的后续请求，或许是其他的，这些HTTP自身都不知道。")]),t._v(" "),_("h3",{attrs:{id:"tcp协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp协议"}},[t._v("#")]),t._v(" TCP协议")]),t._v(" "),_("p",[t._v("TCP是有状态的，它通过包头中的一些控制字段（序列编码等）来表明各个包之间的关系（前后关系，重包与否等等）。所以，通过这个协议你可以做到一个可靠的传输。那么TCP是面向连接的协议是什么意思呢？其实这里的面向连接其实就是“三次握手”。三次握手，首先可以保证对方的存在，其次握手的所交换的内容是为将来进行有状态的传输做准备。")]),t._v(" "),_("h3",{attrs:{id:"udp协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#udp协议"}},[t._v("#")]),t._v(" UDP协议")]),t._v(" "),_("p",[t._v("UDP是无状态的，它仅仅是在IP上加了Port，其他的事情什么也不干。这样它不可能做到可靠的传输，同样也不需要连接。")]),t._v(" "),_("h3",{attrs:{id:"ip协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ip协议"}},[t._v("#")]),t._v(" IP协议")]),t._v(" "),_("p",[t._v("IP是无状态的，它只负责将一个IP包发送到指定的IP地址上去。它不会考虑这个包与前面已经发送的包和后面的包的联系。（可能是重发包、可能是不连续包，它不管）")]),t._v(" "),_("h3",{attrs:{id:"arp协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#arp协议"}},[t._v("#")]),t._v(" ARP协议")]),t._v(" "),_("p",[_("strong",[t._v("ARP协议的缺陷")]),t._v(" ARP协议是建立在信任局域网内所有结点的基础上的，它很高效，但却不安全。它是无状态的协议，不会检查自己是否发过请求包，也不管（其实也不知道）是否是合法的应答，只要收到目标MAC是自己的ARP reply包或arp广播包（包括ARP request和ARP reply），都会接受并缓存。这就为ARP欺骗提供了可能，恶意节点可以发布虚假的ARP报文从而影响网内结点的通信，甚至可以做"),_("code",[t._v("“中间人”")]),t._v("。")])])}),[],!1,null,null,null);v.default=s.exports}}]);